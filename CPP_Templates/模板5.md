# C++ 模板 5： 类模板的继承和成员函数

![类模板](img/类模板.png)

上一篇文章介绍了关于这些模板的基本知识。这篇文章说明对类模板的继承和类模板成员函数的实例化中的特性，这些特性可能会令你感到 surprise。

下面是第一个 surprise，至少我是 surprise 了：

## 类模板的继承成员函数不可用

来看一个简单的例子：

```C++
// inheritance.cpp
#include <iostream>
class Base
{
public:
    void func()                     // (1)
    {                    
        std::cout << "func\n";
    }
};
class Derived : public Base
{
public:
    void callBase()
    {
        func();                      // (2)
    }
};

int main()
{
    std::cout << '\n';
    Derived derived;
    derived.callBase();              
    std::cout << '\n';
}
```

上面的代码实现了类 `Base` 和 `Derived`。`Derived` 是从 `Base` 公共派生出来，因此可以在其成员函数 `callBase`（(2) 行）中使用类 `Base` 的方法 `func`。程序的输出如下，我没有什么要补充的。![inheritance](img/inheritance.png) 

让 `Base` 成为类模板完全改变了程序行为。

```C++
// templateInheritance.cpp
#include <iostream>
template <typename T>
class Base
{
public:
    void func()            			// (1)
    {                    
        std::cout << "func\n";
    }
};
template <typename T>
class Derived: public Base<T>
{
public:
    void callBase()
    {
        func();                       // (2)
    }
};

int main()
{
    std::cout << '\n';
    Derived<int> derived;
    derived.callBase();              
    std::cout << '\n';
}
```

我猜编译器的报错会让你 surprise。 ![templateInheritance1](img/templateInheritance1.png) 

## 导航

[目录](https://github.com/yqZhang4480/TranslateBlogs/blob/master/CPP_Templates/目录.md)	[上一篇](https://github.com/yqZhang4480/TranslateBlogs/blob/master/CPP_Templates/模板4.md)	[下一篇](https://github.com/yqZhang4480/TranslateBlogs/blob/master/CPP_Templates/模板6.md)	[原文](http://www.modernescpp.com/index.php/surprise-included-inheritance-and-member-functions-of-class-templates)

![](./img/tail.png)