# C++ 模板 9：模板特例化

![特例化](img/特例化.png)

首先用模板特例化的一般概念开始这篇文章，在下一篇文章再集中讨论细节问题。

## 模板特例化

模板定义了一系列类和函数的行为。通常情况下，需要对特殊类型或非类型进行特殊处理。因此，你可以将模板完全特例化（下称全特化）。

类模板也可以部分特例化（下称偏特化）。未经特化的模板（下称主模板）可以全特化或偏特化的模板共存。特例化的类的成员不一定要与未特化模板的成员相同。编译器更倾向于选择全特化的模板，然后是偏特化的模板，最后是主模板。

下面的例子应该可以讲清楚这段话。

```C++
template <typename T, int Line, int Column>     // (1)
class Matrix;

template <typename T>                           // (2)
class Matrix<T, 3, 3>{};

template <>                                     // (3)
class Matrix<int, 3, 3>{};
```

* 主模板
  第 (1) 行是主模板。主模板必须在部分或全特化模板之前声明。如果不需要主模板，像第 (1) 行这样的声明就可以了。

* 偏特化
  第 (2) 行是偏特化模板。只有类模板支持偏特化。一个偏特化模板有模板形参和明确指定的模板实参。在这个例子中，类 `Matrix<T, 3, 3>` 的 `T` 是模板形参，数字是模板实参。

* 全特化
  第 (3) 行是全特化模板。“全”意味着所有的模板实参都已明确，模板形参列表为空：正如第 (3) 行的 `template <>` 所示。

### 偏特化与全特化的对比

我是数学出身，在数学计算中可能会有很多线性方程组需要求解。为了更好地理解偏特化与全特化，我想从数学视角提出一个直观的解释：一个一个有n个参数的类模板可以看作一个n维空间。其偏特化是n维空间中的一个子空间，而其全特化是n维空间中的一个点。

现在，我把我的直观解释应用到类模板 `Matrix` 和它的偏特化与全特化模板中。在主模板中（上方代码第 (1) 行），你可以选择一个类型作为模板参数，以及两个 `int` 值作为非类型模板参数。一共有3个参数，因此我们可以把它看作一个3维空间。在第 (2) 行的偏特化的情况下，你只能选择类型。这可以看成3维空间被简化为一条线。因此，主模板 `Matrix` 的偏特化是3维空间的一个子空间。全特化（第 (3) 行）代表3维空间的一个点。

### 使用主模板、偏特化模板、全特化模板

我在这里重复一次之前的例子：

```C++
template <typename T, int Line, int Column>     // (1)
class Matrix;

template <typename T>                           // (2)
class Matrix<T, 3, 3>{};

template <>                                     // (3)
class Matrix<int, 3, 3>{};
```

问题是：当你用各种模板参数实例化 `Matrix` 时会发生什么？这里有三种实例化，你看看编译器创造了什么。

```C++
Matrix<int, 3, 3> m1;          // class Matrix<int, 3, 3>

Matrix<double, 3, 3> m2;       // class Matrix<T, 3, 3> 

Matrix<std::string, 4, 3> m3;  // class Matrix<T, Line, Column> => ERROR
```

 `m1` 使用全特化模板，`m2` 使用偏特化模板，`m3` 使用主模板，因为没有定义而导致错误。

为了理解这个过程，你必须牢记一些规则。下面是特别适用于类模板的偏特化的规则。

#### 模板形参和模板实参之间的依赖关系

* 明确指定的模板实参（`<T, 3, 3>`）的数量和顺序必须与主模板的模板形参列表（`<typename T, int Line, int Column>`）的数量和顺序一致。
* 如果你使用模板参数的默认值，那么不能提供模板实参。只有主模板接受模板参数的默认值。

#### 选择有效的偏特化模板

- 如果模板实例化实参（`Matrix<double, 3, 3>`）是偏特化（`Matrix<T, 3, 3>`）的模板实参的一个子集，编译器就会选择偏特化的模板。

#### 选定之后

1. 若编译器只匹配到了一个特例化模板，则使用之。
2. 若编译器发现多个特例化模板，则编译器使用最为特例化的那个。如果“最为特例化的”有多个，编译器会抛出错误。
3. 若编译器没有找到特例化模板，则使用主模板。

这里需要解释一下编译器是怎么比较哪个特例化模板更为特例化的：

模板A比模板B更特例化，即：

* 模板B可以接受模板A可以接受的所有参数。
* 模板B可以接受模板A不能接受的参数。

更形式化的表述可见于 [cppreference.com/partial_specialization](https://en.cppreference.com/w/cpp/language/partial_specialization)。

## 下一篇

这篇文章应该为你提供了关于模板特例化的基本知识，但在C++中总是有更多的细节。例如，偏特化、全特化的行为就像编译时的if，而全特化的类或函数模板与普通的类或函数很相似。

## 导航

[目录](目录.md)	[上一篇](模板8.md)	[下一篇](10.md)	[原文](http://www.modernescpp.com/index.php/template-specialization)

![](./img/tail.png)