# C++ 模板 12：模板实例化

![模板实例化](img/模板实例化.png)

模板实例化是指从一个函数模板或类模板中创建一个具体的函数或一个具体的类。模板的实例化可以是隐式的（编译器生成的）或显式的（用户提供的）。

## 隐式实例化

隐式实例化应该是你的默认选择。隐式实例化意味着编译器会自动使用提供的模板实参生成具体的函数或类。一般来说，编译器也会从函数的实参中推导出模板实参。在 C++17 中，编译器也可以推导出类模板的模板实参。

```C++
// implicitTemplateInstantiation.cpp

#include <iostream>
#include <string>
#include <vector>

template <typename T>
class MyClass{
 public:
    MyClass(T t) { }
    std::string getType() const {
        return typeid(T).name();
    }
};

template<typename T>
bool isSmaller(T fir, T sec){
    return fir < sec;
}

int main(){

    std::cout << '\n';

    std::cout << std::boolalpha;
  
    std::vector vec{1, 2, 3, 4, 5};          // (1)
    std::cout << "vec.size(): " << vec.size() << '\n';
  
    MyClass myClass(5);                      // (2)
    std::cout << "myClass.getType(): " << myClass.getType() << '\n';
  
    std::cout << '\n';
  
    std::cout << "isSmaller(5, 10): " 
              << isSmaller(5, 10) << '\n';   // (3)
    std::cout << "isSmaller<double>(5.5f, 6.5): " 
              << isSmaller<double>(5.5f, 6.5) << '\n';    // (4)
  
    std::cout << '\n';
  
}
```

第 (1) 行和第 (2) 行使用了类模板参数推导。第 (3) 行也推导出了它的模板参数。而在第 (4) 行，模板参数double被明确指定：`isSmaller<double>(5.5f, 6.5)`。

编译器为每个隐式模板实例化创建一个具体的函数或类。[C++ Insights](https://cppinsights.io/s/e8145723)

这个自动过程非常舒适，但也有一些缺点。

* 当你隐式实例化一个模板时，模板的定义通常在头文件中可见。也许，你不想公开这个定义。
* 当你需要一个特定的模板实参时，如果它在具体的翻译单元中不可用，编译器就会实例化。一个翻译单元是C预处理器处理后的源文件。通常情况下，链接器会删除所有多余的模板实例并保留一个。这是对时间和空间的浪费。

这两个问题都可以通过显式模板实例化来解决。











## 导航

[目录](目录.md)	[上一篇](11.md)	[下一篇](13.md)	[原文](http://www.modernescpp.com/index.php/template-instantiation)

![](./img/tail.png)